From 92331ef6eef37b23e0a909ebe9a27bd5e0f7384b Mon Sep 17 00:00:00 2001
From: Hirosh Dabui <hirosh@dabui.de>
Date: Sun, 21 Apr 2024 13:58:21 +0200
Subject: [PATCH] Add SV32 support patches for KianV RISC-V SoC

---
 drivers/gpio/Kconfig                        |   8 +
 drivers/gpio/Makefile                       |   2 +
 drivers/gpio/gpio-kianv.c                   | 124 ++++++++++++++
 drivers/net/ethernet/microchip/enc28j60.c   | 149 ++++++++++++++++
 drivers/net/ethernet/microchip/encx24j600.c | 100 ++++++++++-
 drivers/net/ethernet/wiznet/w5100.c         |  70 +++++++-
 drivers/spi/Kconfig                         |  18 ++
 drivers/spi/Makefile                        |   3 +
 drivers/spi/spi-kianV-simple.c              | 149 ++++++++++++++++
 drivers/spi/spi-kianV-simple2.c             | 149 ++++++++++++++++
 drivers/spi/spi-kianV-simple3.c             | 180 ++++++++++++++++++++
 drivers/staging/fbtft/fb_ssd1331.c          |  38 ++++-
 drivers/staging/fbtft/fbtft-bus.c           |   9 +-
 drivers/staging/fbtft/fbtft-core.c          |  34 +++-
 include/linux/spi/spi.h                     |   1 +
 sound/Kconfig                               |   2 +
 sound/Makefile                              |   3 +-
 sound/kianv/Kconfig                         |   4 +
 sound/kianv/Makefile                        |   1 +
 sound/kianv/kianv-snd.c                     | 111 ++++++++++++
 20 files changed, 1141 insertions(+), 14 deletions(-)
 create mode 100644 drivers/gpio/gpio-kianv.c
 create mode 100644 drivers/spi/spi-kianV-simple.c
 create mode 100644 drivers/spi/spi-kianV-simple2.c
 create mode 100644 drivers/spi/spi-kianV-simple3.c
 create mode 100644 sound/kianv/Kconfig
 create mode 100644 sound/kianv/Makefile
 create mode 100644 sound/kianv/kianv-snd.c

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 93ee3aa092f8..a3d244ca56ca 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -801,6 +801,14 @@ config GPIO_XILINX
 	help
 	  Say yes here to support the Xilinx FPGA GPIO device.
 
+config GPIO_KIANV
+	tristate "KianV RISC-V GPIO support"
+	select GPIO_GENERIC
+	select GPIOLIB_IRQCHIP
+	depends on OF_GPIO
+	help
+	  Say yes here to support the KianV RISC-V FPGA GPIO device.
+
 config GPIO_XLP
 	tristate "Cavium ThunderX2 GPIO support"
 	depends on ARCH_THUNDER2 || COMPILE_TEST
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index af3ba4d81b58..d9495777cf25 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -206,3 +206,5 @@ obj-$(CONFIG_GPIO_XTENSA)		+= gpio-xtensa.o
 obj-$(CONFIG_GPIO_ZEVIO)		+= gpio-zevio.o
 obj-$(CONFIG_GPIO_ZYNQ)			+= gpio-zynq.o
 obj-$(CONFIG_GPIO_ZYNQMP_MODEPIN)	+= gpio-zynqmp-modepin.o
+obj-$(CONFIG_GPIO_KIANV)	+= gpio-kianv.o
+
diff --git a/drivers/gpio/gpio-kianv.c b/drivers/gpio/gpio-kianv.c
new file mode 100644
index 000000000000..d50a8771173e
--- /dev/null
+++ b/drivers/gpio/gpio-kianv.c
@@ -0,0 +1,124 @@
+/*
+ *  kianv.v - a simple RISC-V rv32ima
+ *
+ *  copyright (c) 2023 hirosh dabui <hirosh@dabui.de>
+ *
+ *  permission to use, copy, modify, and/or distribute this software for any
+ *  purpose with or without fee is hereby granted, provided that the above
+ *  copyright notice and this permission notice appear in all copies.
+ *
+ *  the software is provided "as is" and the author disclaims all warranties
+ *  with regard to this software including all implied warranties of
+ *  merchantability and fitness. in no event shall the author be liable for
+ *  any special, direct, indirect, or consequential damages or any damages
+ *  whatsoever resulting from loss of use, data or profits, whether in an
+ *  action of contract, negligence or other tortious action, arising out of
+ *  or in connection with the use or performance of this software.
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/gpio/driver.h>
+
+struct kianv_gpio {
+    void __iomem *base;
+    struct gpio_chip gc;
+};
+
+#define GPIO_DIR_OFFSET    0x00
+#define GPIO_OUTPUT_OFFSET 0x04
+#define GPIO_INPUT_OFFSET  0x08
+
+static int kianv_gpio_get(struct gpio_chip *gc, unsigned int offset)
+{
+    struct kianv_gpio *kv = gpiochip_get_data(gc);
+    return readl(kv->base + GPIO_INPUT_OFFSET) & (1 << offset);
+}
+
+static void kianv_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)
+{
+    struct kianv_gpio *kv = gpiochip_get_data(gc);
+    u32 reg_val = readl(kv->base + GPIO_OUTPUT_OFFSET);
+
+    if (value)
+        reg_val |= (1 << offset);
+    else
+        reg_val &= ~(1 << offset);
+
+    writel(reg_val, kv->base + GPIO_OUTPUT_OFFSET);
+}
+
+static int kianv_gpio_dir_out(struct gpio_chip *gc, unsigned int offset, int value)
+{
+    struct kianv_gpio *kv = gpiochip_get_data(gc);
+    u32 reg_val = readl(kv->base + GPIO_DIR_OFFSET);
+    reg_val |= (1 << offset);
+    writel(reg_val, kv->base + GPIO_DIR_OFFSET);
+    kianv_gpio_set(gc, offset, value);
+    return 0;
+}
+
+static int kianv_gpio_dir_in(struct gpio_chip *gc, unsigned int offset)
+{
+    struct kianv_gpio *kv = gpiochip_get_data(gc);
+    u32 reg_val = readl(kv->base + GPIO_DIR_OFFSET);
+    reg_val &= ~(1 << offset);
+    writel(reg_val, kv->base + GPIO_DIR_OFFSET);
+    return 0;
+}
+
+static const struct gpio_chip kianv_chip = {
+    .label            = "kianv-gpio",
+    .get              = kianv_gpio_get,
+    .set              = kianv_gpio_set,
+    .direction_output = kianv_gpio_dir_out,
+    .direction_input  = kianv_gpio_dir_in,
+    .base             = -1,  // dynamically assigned
+    .ngpio            = 32,  // assuming 32 GPIOs; adjust as necessary
+    .owner            = THIS_MODULE,
+};
+
+static int kianv_gpio_probe(struct platform_device *pdev)
+{
+    struct kianv_gpio *kv;
+    struct resource *res;
+
+
+    kv = devm_kzalloc(&pdev->dev, sizeof(*kv), GFP_KERNEL);
+    if (!kv)
+        return -ENOMEM;
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    kv->base = devm_ioremap_resource(&pdev->dev, res);
+    if (IS_ERR(kv->base))
+        return PTR_ERR(kv->base);
+
+    kv->gc = kianv_chip;
+    kv->gc.parent = &pdev->dev;
+    platform_set_drvdata(pdev, kv);
+
+    dev_info(&pdev->dev, "Kianv GPIO driver probed successfully\n");
+    return gpiochip_add_data(&kv->gc, kv);
+}
+
+static const struct of_device_id kianv_gpio_of_match[] = {
+    { .compatible = "kianV,kianv-gpio", },
+    { /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, kianv_gpio_of_match);
+
+static struct platform_driver kianv_gpio_driver = {
+    .driver = {
+        .name = "kianv-gpio",
+        .of_match_table = kianv_gpio_of_match,
+    },
+    .probe = kianv_gpio_probe,
+};
+module_platform_driver(kianv_gpio_driver);
+
+MODULE_AUTHOR("Hirosh Dabui <hirosh@dabui.de");
+MODULE_DESCRIPTION("KianV GPIO Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/net/ethernet/microchip/enc28j60.c b/drivers/net/ethernet/microchip/enc28j60.c
index d6c9491537e4..cfdaf606f500 100644
--- a/drivers/net/ethernet/microchip/enc28j60.c
+++ b/drivers/net/ethernet/microchip/enc28j60.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2007 Eurek srl
  * Author: Claudio Lanconelli <lanconelli.claudio@eptar.com>
+ * Copyright (C) 2024 Hirosh Dabui <hirosh@dabui.de>
  * based on enc28j60.c written by David Anders for 2.4 kernel version
  *
  * $Id: enc28j60.c,v 1.22 2007/12/20 10:47:01 claudio Exp $
@@ -1117,6 +1118,7 @@ static int enc28j60_rx_interrupt(struct net_device *ndev)
 	return ret;
 }
 
+#if 0
 static irqreturn_t enc28j60_irq(int irq, void *dev_id)
 {
 	struct enc28j60_net *priv = dev_id;
@@ -1226,6 +1228,135 @@ static irqreturn_t enc28j60_irq(int irq, void *dev_id)
 
 	return IRQ_HANDLED;
 }
+#endif
+static struct task_struct *net_kianv_thread;
+static void __iomem *virt_addr;
+
+#define KIANV_GPIO_HW_ADDR 0x10000700
+
+// Initial sleep time in milliseconds
+#define INITIAL_SLEEP_TIME 50
+#define MIN_SLEEP_TIME 10
+#define MAX_SLEEP_TIME 200
+#define INCREMENT_SLEEP_TIME 10
+// unsigned int sleep_ms = INCREMENT_SLEEP_TIME;
+static int net_kianv_thread_function(void *data) {
+    struct net_device *dev = data;
+    struct enc28j60_net *priv = netdev_priv(dev);
+    struct net_device *ndev = priv->netdev;
+    int intflags, loop;
+
+    virt_addr = ioremap(KIANV_GPIO_HW_ADDR, PAGE_SIZE);
+    if (!virt_addr) {
+        printk(KERN_ERR "Failed to map physical address\n");
+        return -1; // Can't proceed without mapping
+    }
+
+    do {
+      u32 value;
+      value = readl(virt_addr + 0x08);
+      if (!((value >> 8) & 1)) {
+        do {
+          loop = 0;
+          intflags = locked_regb_read(priv, EIR);
+          /* DMA interrupt handler (not currently used) */
+          if ((intflags & EIR_DMAIF) != 0) {
+            loop++;
+            if (netif_msg_intr(priv))
+              netdev_printk(KERN_DEBUG, ndev, "intDMA(%d)\n",
+                  loop);
+            locked_reg_bfclr(priv, EIR, EIR_DMAIF);
+          }
+          /* LINK changed handler */
+          if ((intflags & EIR_LINKIF) != 0) {
+            loop++;
+            if (netif_msg_intr(priv))
+              netdev_printk(KERN_DEBUG, ndev, "intLINK(%d)\n",
+                  loop);
+            enc28j60_check_link_status(ndev);
+            /* read PHIR to clear the flag */
+            enc28j60_phy_read(priv, PHIR);
+          }
+          /* TX complete handler */
+          if (((intflags & EIR_TXIF) != 0) &&
+              ((intflags & EIR_TXERIF) == 0)) {
+            bool err = false;
+            loop++;
+            if (netif_msg_intr(priv))
+              netdev_printk(KERN_DEBUG, ndev, "intTX(%d)\n",
+                  loop);
+            priv->tx_retry_count = 0;
+            if (locked_regb_read(priv, ESTAT) & ESTAT_TXABRT) {
+              if (netif_msg_tx_err(priv))
+                netdev_err(ndev, "Tx Error (aborted)\n");
+              err = true;
+            }
+            if (netif_msg_tx_done(priv)) {
+              u8 tsv[TSV_SIZE];
+              enc28j60_read_tsv(priv, tsv);
+              enc28j60_dump_tsv(priv, "Tx Done", tsv);
+            }
+            enc28j60_tx_clear(ndev, err);
+            locked_reg_bfclr(priv, EIR, EIR_TXIF);
+          }
+          /* TX Error handler */
+          if ((intflags & EIR_TXERIF) != 0) {
+            u8 tsv[TSV_SIZE];
+
+            loop++;
+            if (netif_msg_intr(priv))
+              netdev_printk(KERN_DEBUG, ndev, "intTXErr(%d)\n",
+                  loop);
+            locked_reg_bfclr(priv, ECON1, ECON1_TXRTS);
+            enc28j60_read_tsv(priv, tsv);
+            if (netif_msg_tx_err(priv))
+              enc28j60_dump_tsv(priv, "Tx Error", tsv);
+            /* Reset TX logic */
+            mutex_lock(&priv->lock);
+            nolock_reg_bfset(priv, ECON1, ECON1_TXRST);
+            nolock_reg_bfclr(priv, ECON1, ECON1_TXRST);
+            nolock_txfifo_init(priv, TXSTART_INIT, TXEND_INIT);
+            mutex_unlock(&priv->lock);
+            /* Transmit Late collision check for retransmit */
+            if (TSV_GETBIT(tsv, TSV_TXLATECOLLISION)) {
+              if (netif_msg_tx_err(priv))
+                netdev_printk(KERN_DEBUG, ndev,
+                    "LateCollision TXErr (%d)\n",
+                    priv->tx_retry_count);
+              if (priv->tx_retry_count++ < MAX_TX_RETRYCOUNT)
+                locked_reg_bfset(priv, ECON1,
+                    ECON1_TXRTS);
+              else
+                enc28j60_tx_clear(ndev, true);
+            } else
+              enc28j60_tx_clear(ndev, true);
+            locked_reg_bfclr(priv, EIR, EIR_TXERIF | EIR_TXIF);
+          }
+          /* RX Error handler */
+          if ((intflags & EIR_RXERIF) != 0) {
+            loop++;
+            if (netif_msg_intr(priv))
+              netdev_printk(KERN_DEBUG, ndev, "intRXErr(%d)\n",
+                  loop);
+            /* Check free FIFO space to flag RX overrun */
+            if (enc28j60_get_free_rxfifo(priv) <= 0) {
+              if (netif_msg_rx_err(priv))
+                netdev_printk(KERN_DEBUG, ndev, "RX Overrun\n");
+              ndev->stats.rx_dropped++;
+            }
+            locked_reg_bfclr(priv, EIR, EIR_RXERIF);
+          }
+          /* RX handler */
+          if (enc28j60_rx_interrupt(ndev))
+            loop++;
+        } while (loop);
+      }
+      msleep(20);
+    } while (!kthread_should_stop());
+
+    return 0;
+}
+
 
 /*
  * Hardware transmit function.
@@ -1356,6 +1487,22 @@ static int enc28j60_net_open(struct net_device *dev)
 	 * the queueing layer of the networking.
 	 */
 	netif_start_queue(dev);
+        printk(KERN_INFO "enc28j60: Creating thread\n");
+
+	/* Check if the thread is already running */
+	if (!net_kianv_thread || IS_ERR(net_kianv_thread)) {
+		printk(KERN_INFO "enc28j60: Creating thread\n");
+		net_kianv_thread = kthread_run(net_kianv_thread_function, dev, "net_kianv_thread");
+		if (!IS_ERR(net_kianv_thread)) {
+			printk(KERN_INFO "Thread created successfully\n");
+		} else {
+			printk(KERN_ERR "Thread creation failed\n");
+			net_kianv_thread = NULL; // Reset in case of failure
+		}
+	} else {
+		printk(KERN_INFO "Thread is already running\n");
+	}
+
 
 	return 0;
 }
@@ -1561,6 +1708,7 @@ static int enc28j60_probe(struct spi_device *spi)
 	/* Board setup must set the relevant edge trigger type;
 	 * level triggers won't currently work.
 	 */
+	/*
 	ret = request_threaded_irq(spi->irq, NULL, enc28j60_irq, IRQF_ONESHOT,
 				   DRV_NAME, priv);
 	if (ret < 0) {
@@ -1569,6 +1717,7 @@ static int enc28j60_probe(struct spi_device *spi)
 				spi->irq, ret);
 		goto error_irq;
 	}
+	*/
 
 	dev->if_port = IF_PORT_10BASET;
 	dev->irq = spi->irq;
diff --git a/drivers/net/ethernet/microchip/encx24j600.c b/drivers/net/ethernet/microchip/encx24j600.c
index b011bf5c2305..ad204e4f40c1 100644
--- a/drivers/net/ethernet/microchip/encx24j600.c
+++ b/drivers/net/ethernet/microchip/encx24j600.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2015 Gridpoint
  * Author: Jon Ringle <jringle@gridpoint.com>
+ * Copyright (C) 2024 Hirosh Dabui <hirosh@dabui.de>
  */
 
 #include <linux/device.h>
@@ -397,6 +398,7 @@ static void encx24j600_rx_packets(struct encx24j600_priv *priv, u8 packet_count)
 	}
 }
 
+#if 0
 static irqreturn_t encx24j600_isr(int irq, void *dev_id)
 {
 	struct encx24j600_priv *priv = dev_id;
@@ -445,6 +447,7 @@ static irqreturn_t encx24j600_isr(int irq, void *dev_id)
 
 	return IRQ_HANDLED;
 }
+#endif
 
 static int encx24j600_soft_reset(struct encx24j600_priv *priv)
 {
@@ -764,11 +767,91 @@ static int encx24j600_set_mac_address(struct net_device *dev, void *addr)
 	eth_hw_addr_set(dev, address->sa_data);
 	return encx24j600_set_hw_macaddr(dev);
 }
+static struct task_struct *net_kianv_thread;
+static void __iomem *virt_addr;
+
+#define KIANV_GPIO_HW_ADDR 0x10000700
+
+// Initial sleep time in milliseconds
+#define INITIAL_SLEEP_TIME 50
+#define MIN_SLEEP_TIME 10
+#define MAX_SLEEP_TIME 200
+#define INCREMENT_SLEEP_TIME 10
+// unsigned int sleep_ms = INCREMENT_SLEEP_TIME;
+static int net_kianv_thread_function(void *data) {
+  struct net_device *dev = data;
+  struct encx24j600_priv *priv = netdev_priv(dev);
+
+  virt_addr = ioremap(KIANV_GPIO_HW_ADDR, PAGE_SIZE);
+  if (!virt_addr) {
+    printk(KERN_ERR "Failed to map physical address\n");
+    return -1; // Can't proceed without mapping
+  }
+
+  do {
+    u32 value;
+    value = readl(virt_addr + 0x08);
+    if (!((value >> 8) & 1)) {
+      int eir;
+
+      /* Clear interrupts */
+      encx24j600_cmd(priv, CLREIE);
+
+      eir = encx24j600_read_reg(priv, EIR);
+
+      if (eir & LINKIF)
+        encx24j600_int_link_handler(priv);
+
+      if (eir & TXIF)
+        encx24j600_tx_complete(priv, false);
+
+      if (eir & TXABTIF)
+        encx24j600_tx_complete(priv, true);
+
+      if (eir & RXABTIF) {
+        if (eir & PCFULIF) {
+          /* Packet counter is full */
+          netif_err(priv, rx_err, dev, "Packet counter full\n");
+        }
+        dev->stats.rx_dropped++;
+        encx24j600_clr_bits(priv, EIR, RXABTIF);
+      }
+
+      if (eir & PKTIF) {
+        u8 packet_count;
+
+        mutex_lock(&priv->lock);
+
+        packet_count = encx24j600_read_reg(priv, ESTAT) & 0xff;
+        while (packet_count) {
+          encx24j600_rx_packets(priv, packet_count);
+          packet_count = encx24j600_read_reg(priv, ESTAT) & 0xff;
+        }
+
+        mutex_unlock(&priv->lock);
+      }
+
+      /* Enable interrupts */
+      encx24j600_cmd(priv, SETEIE);
+
+      //sleep_ms = MIN_SLEEP_TIME;
+    } else {
+      //sleep_ms = min((sleep_ms + INCREMENT_SLEEP_TIME), MAX_SLEEP_TIME);
+    }
+    //msleep(sleep_ms);
+    msleep(20);
+  } while (!kthread_should_stop());
+
+  return 0;
+}
+
+
 
 static int encx24j600_open(struct net_device *dev)
 {
 	struct encx24j600_priv *priv = netdev_priv(dev);
 
+        /*
 	int ret = request_threaded_irq(priv->ctx.spi->irq, NULL, encx24j600_isr,
 				       IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 				       DRV_NAME, priv);
@@ -777,13 +860,28 @@ static int encx24j600_open(struct net_device *dev)
 			   priv->ctx.spi->irq, ret);
 		return ret;
 	}
+        */
 
 	encx24j600_hw_disable(priv);
 	encx24j600_hw_init(priv);
 	encx24j600_hw_enable(priv);
 	netif_start_queue(dev);
 
-	return 0;
+  /* Check if the thread is already running */
+  if (!net_kianv_thread || IS_ERR(net_kianv_thread)) {
+      printk(KERN_INFO "encx24j600: Creating thread\n");
+      net_kianv_thread = kthread_run(net_kianv_thread_function, dev, "net_kianv_thread");
+      if (!IS_ERR(net_kianv_thread)) {
+          printk(KERN_INFO "Thread created successfully\n");
+      } else {
+          printk(KERN_ERR "Thread creation failed\n");
+          net_kianv_thread = NULL; // Reset in case of failure
+      }
+  } else {
+      printk(KERN_INFO "Thread is already running\n");
+  }
+
+    return 0;
 }
 
 static int encx24j600_stop(struct net_device *dev)
diff --git a/drivers/net/ethernet/wiznet/w5100.c b/drivers/net/ethernet/wiznet/w5100.c
index b77f096eaf99..5082595a0b2c 100644
--- a/drivers/net/ethernet/wiznet/w5100.c
+++ b/drivers/net/ethernet/wiznet/w5100.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2006-2008 WIZnet Co.,Ltd.
  * Copyright (C) 2012 Mike Sinkovsky <msink@permonline.ru>
+ * Copyright (C) 2024 Hirosh Dabui <hirosh@dabui.de>
  */
 
 #include <linux/kernel.h>
@@ -910,6 +911,7 @@ static int w5100_napi_poll(struct napi_struct *napi, int budget)
 	return rx_count;
 }
 
+#if 0
 static irqreturn_t w5100_interrupt(int irq, void *ndev_instance)
 {
 	struct net_device *ndev = ndev_instance;
@@ -936,7 +938,53 @@ static irqreturn_t w5100_interrupt(int irq, void *ndev_instance)
 
 	return IRQ_HANDLED;
 }
+#endif
+static struct task_struct *net_kianv_thread;
+static void __iomem *virt_addr;
+
+#define KIANV_GPIO_HW_ADDR 0x10000700
+static int net_kianv_thread_function(void *data) {
+	struct net_device *ndev = data;
+	struct w5100_priv *priv = netdev_priv(ndev);
+
+	virt_addr = ioremap(KIANV_GPIO_HW_ADDR, PAGE_SIZE);
+	if (!virt_addr) {
+		printk(KERN_ERR "Failed to map physical address\n");
+		return -1; // Can't proceed without mapping
+	}
+
+  do {
+    u32 value;
+    value = readl(virt_addr + 0x08);
+    if (!((value >> 8) & 1)) {
+      int ir = w5100_read(priv, W5100_S0_IR(priv));
+      if (ir) {
+
+        w5100_write(priv, W5100_S0_IR(priv), ir);
+
+        if (ir & S0_IR_SENDOK) {
+          netif_dbg(priv, tx_done, ndev, "tx done\n");
+          netif_wake_queue(ndev);
+        }
+
+        if (ir & S0_IR_RECV) {
+          w5100_disable_intr(priv);
+
+          if (priv->ops->may_sleep)
+            queue_work(priv->xfer_wq, &priv->rx_work);
+          else
+            napi_schedule(&priv->napi);
+        }
+      }
+    }
+
+    msleep(20);
+  } while (!kthread_should_stop());
 
+  return 0;
+}
+
+#if 0
 static irqreturn_t w5100_detect_link(int irq, void *ndev_instance)
 {
 	struct net_device *ndev = ndev_instance;
@@ -954,6 +1002,7 @@ static irqreturn_t w5100_detect_link(int irq, void *ndev_instance)
 
 	return IRQ_HANDLED;
 }
+#endif
 
 static void w5100_setrx_work(struct work_struct *work)
 {
@@ -1169,6 +1218,7 @@ int w5100_probe(struct device *dev, const struct w5100_ops *ops,
 	if (err)
 		goto err_hw;
 
+#if 0
 	if (ops->may_sleep) {
 		err = request_threaded_irq(priv->irq, NULL, w5100_interrupt,
 					   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
@@ -1179,7 +1229,22 @@ int w5100_probe(struct device *dev, const struct w5100_ops *ops,
 	}
 	if (err)
 		goto err_hw;
+#endif
+	/* Check if the thread is already running */
+	if (!net_kianv_thread || IS_ERR(net_kianv_thread)) {
+		printk(KERN_INFO "w5100: Creating thread\n");
+		net_kianv_thread = kthread_run(net_kianv_thread_function, ndev, "net_kianv_thread");
+		if (!IS_ERR(net_kianv_thread)) {
+			printk(KERN_INFO "Thread created successfully\n");
+		} else {
+			printk(KERN_ERR "Thread creation failed\n");
+			net_kianv_thread = NULL; // Reset in case of failure
+		}
+	} else {
+		printk(KERN_INFO "Thread is already running\n");
+	}
 
+#if 0
 	if (gpio_is_valid(priv->link_gpio)) {
 		char *link_name = devm_kzalloc(dev, 16, GFP_KERNEL);
 
@@ -1195,11 +1260,12 @@ int w5100_probe(struct device *dev, const struct w5100_ops *ops,
 					    link_name, priv->ndev) < 0)
 			priv->link_gpio = -EINVAL;
 	}
+#endif
 
 	return 0;
 
-err_gpio:
-	free_irq(priv->irq, ndev);
+//err_gpio:
+//	free_irq(priv->irq, ndev);
 err_hw:
 	destroy_workqueue(priv->xfer_wq);
 err_wq:
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index f51f9466e518..f7218d433307 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -689,6 +689,24 @@ config SPI_MICROCHIP_CORE_QSPI
 	  PolarFire SoC.
 	  If built as a module, it will be called spi-microchip-core-qspi.
 
+config SPI_KIANV_SPI_SIMPLE0
+	tristate "KianV RISC-V FPGA SPI0 controller"
+	depends on SPI_MASTER
+	help
+	  This enables the QSPI driver for KianV SPI Simple controller
+
+config SPI_KIANV_SPI_SIMPLE1
+	tristate "KianV RISC-V FPGA SPI1 controller"
+	depends on SPI_MASTER
+	help
+	  This enables the QSPI driver for KianV SPI Simple controller
+
+config SPI_KIANV_SPI_SIMPLE2
+	tristate "KianV RISC-V FPGA SPI2 controller"
+	depends on SPI_MASTER
+	help
+	  This enables the QSPI driver for KianV SPI Simple controller
+
 config SPI_MT65XX
 	tristate "MediaTek SPI controller"
 	depends on ARCH_MEDIATEK || COMPILE_TEST
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index aea5e54de195..ad1e0b7a2802 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -15,6 +15,9 @@ obj-$(CONFIG_SPI_LOOPBACK_TEST)		+= spi-loopback-test.o
 
 # SPI master controller drivers (bus)
 obj-$(CONFIG_SPI_AIROHA_SNFI)		+= spi-airoha-snfi.o
+obj-$(CONFIG_SPI_KIANV_SPI_SIMPLE0)     += spi-kianV-simple.o
+obj-$(CONFIG_SPI_KIANV_SPI_SIMPLE1)     += spi-kianV-simple2.o
+obj-$(CONFIG_SPI_KIANV_SPI_SIMPLE2)     += spi-kianV-simple3.o
 obj-$(CONFIG_SPI_ALTERA)		+= spi-altera-platform.o
 obj-$(CONFIG_SPI_ALTERA_CORE)		+= spi-altera-core.o
 obj-$(CONFIG_SPI_ALTERA_DFL)		+= spi-altera-dfl.o
diff --git a/drivers/spi/spi-kianV-simple.c b/drivers/spi/spi-kianV-simple.c
new file mode 100644
index 000000000000..6d22be1c0796
--- /dev/null
+++ b/drivers/spi/spi-kianV-simple.c
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * kianV-Simple SPI controller driver
+ *
+ * Copyright (C) 2019 Antmicro Ltd. <www.antmicro.com>
+ * Copyright (C) 2021 Sylvain Munaut <tnt@246tNt.com>
+ * Copyright (C) 2023 Hirosh Dabui <hirosh@dabui.de>
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "kianVspi-simple"
+
+struct kianVspi_regs {
+	uint32_t ctrl;
+	uint32_t data;
+} __attribute__((packed,aligned(4)));
+
+struct kianVspi_hw {
+	struct spi_controller *master;
+	volatile struct kianVspi_regs __iomem *regs;
+};
+
+static void kianVspi_set_cs(struct spi_device *spi, bool cs_n)
+{
+	struct kianVspi_hw *hw = spi_controller_get_devdata(spi->controller);
+
+	/* Set chip select */
+	hw->regs->ctrl = (cs_n ? 0 : BIT(spi->chip_select[0]));
+}
+
+static int kianVspi_transfer_one(struct spi_controller *ctrl, struct spi_device *spi,
+                                 struct spi_transfer *t)
+{
+    struct kianVspi_hw *hw = spi_controller_get_devdata(ctrl);
+    const u8 *tx = t->tx_buf;
+    u8 *rx = t->rx_buf;
+    int i;
+    unsigned long timeout;
+
+    if (!hw || !t) {
+        return -EINVAL;
+    }
+
+    for (i = 0; i < t->len; i++) {
+        while ((hw->regs->ctrl & 0x80000000) != 0) {
+            cpu_relax();
+        }
+
+        hw->regs->data = tx ? *tx++ : 0x00;
+
+        timeout = jiffies + msecs_to_jiffies(100);
+        while ((hw->regs->ctrl & 0x80000000) != 0) {
+            cpu_relax();
+        }
+
+        if (rx) {
+            *rx++ = hw->regs->data;
+        }
+    }
+
+    return 0;
+}
+
+static int kianVspi_setup(struct spi_device *spi)
+{
+    return 0;
+}
+
+static int kianVspi_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct kianVspi_hw *hw;
+	struct spi_controller *master;
+	//struct resource *res;
+	int ret;
+	u32 val;
+
+	master = spi_alloc_host(&pdev->dev, sizeof(*hw));
+	if (!master)
+		return -ENOMEM;
+
+	master->dev.of_node = pdev->dev.of_node;
+	master->bus_num = pdev->id;
+	master->mode_bits = SPI_MODE_0;
+	master->bits_per_word_mask = SPI_BPW_MASK(8);
+	master->set_cs = kianVspi_set_cs;
+	master->transfer_one = kianVspi_transfer_one;
+	master->setup = kianVspi_setup;
+	master->flags = 0;
+
+	/* get sck frequency */
+	ret = of_property_read_u32(node, "kianVfpga,sck-frequency", &val);
+	if (ret)
+		goto err;
+
+	master->min_speed_hz = val;
+	master->max_speed_hz = val;
+
+	/* get num cs */
+	ret = of_property_read_u32(node, "kianVfpga,num-cs", &val);
+	if (ret)
+		goto err;
+	master->num_chipselect = val;
+
+	hw = spi_controller_get_devdata(master);
+	hw->master = master;
+
+	/* get base address */
+	hw->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);
+	if (IS_ERR((void*)hw->regs)) {
+		ret = PTR_ERR((void*)hw->regs);
+		goto err;
+	}
+
+	/* register controller */
+	ret = spi_register_controller(spi_controller_get(master));
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	spi_controller_put(master);
+	return ret;
+}
+
+static const struct of_device_id kianVspi_match[] = {
+	{ .compatible = "kianVfpga,kianVspi-simple" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, kianVspi_match);
+
+static struct platform_driver kianVspi_driver = {
+	.probe = kianVspi_probe,
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = of_match_ptr(kianVspi_match)
+	}
+};
+module_platform_driver(kianVspi_driver)
+
+MODULE_AUTHOR("Hirosh Dabui <hirosh@dabui.de");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/drivers/spi/spi-kianV-simple2.c b/drivers/spi/spi-kianV-simple2.c
new file mode 100644
index 000000000000..1de3da4e72ff
--- /dev/null
+++ b/drivers/spi/spi-kianV-simple2.c
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * kianV-Simple SPI controller driver
+ *
+ * Copyright (C) 2019 Antmicro Ltd. <www.antmicro.com>
+ * Copyright (C) 2021 Sylvain Munaut <tnt@246tNt.com>
+ * Copyright (C) 2023 Hirosh Dabui <hirosh@dabui.de>
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "kianVspi-simple2"
+
+struct kianVspi_regs {
+	uint32_t ctrl;
+	uint32_t data;
+} __attribute__((packed,aligned(4)));
+
+struct kianVspi_hw {
+	struct spi_controller *master;
+	volatile struct kianVspi_regs __iomem *regs;
+};
+
+static void kianVspi_set_cs(struct spi_device *spi, bool cs_n)
+{
+	struct kianVspi_hw *hw = spi_controller_get_devdata(spi->controller);
+
+	/* Set chip select */
+	hw->regs->ctrl = (cs_n ? 0 : BIT(spi->chip_select[0]));
+}
+
+static int kianVspi_transfer_one(struct spi_controller *ctrl, struct spi_device *spi,
+                                 struct spi_transfer *t)
+{
+    struct kianVspi_hw *hw = spi_controller_get_devdata(ctrl);
+    const u8 *tx = t->tx_buf;
+    u8 *rx = t->rx_buf;
+    int i;
+    unsigned long timeout;
+
+    if (!hw || !t) {
+        return -EINVAL;
+    }
+
+    for (i = 0; i < t->len; i++) {
+        while ((hw->regs->ctrl & 0x80000000) != 0) {
+            cpu_relax();
+        }
+
+        hw->regs->data = tx ? *tx++ : 0x00;
+
+        timeout = jiffies + msecs_to_jiffies(100);
+        while ((hw->regs->ctrl & 0x80000000) != 0) {
+            cpu_relax();
+        }
+
+        if (rx) {
+            *rx++ = hw->regs->data;
+        }
+    }
+
+    return 0;
+}
+
+static int kianVspi_setup(struct spi_device *spi)
+{
+    return 0;
+}
+
+static int kianVspi_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct kianVspi_hw *hw;
+	struct spi_controller *master;
+	//struct resource *res;
+	int ret;
+	u32 val;
+
+	master = spi_alloc_host(&pdev->dev, sizeof(*hw));
+	if (!master)
+		return -ENOMEM;
+
+	master->dev.of_node = pdev->dev.of_node;
+	master->bus_num = pdev->id;
+	master->mode_bits = SPI_MODE_0;
+	master->bits_per_word_mask = SPI_BPW_MASK(8);
+	master->set_cs = kianVspi_set_cs;
+	master->transfer_one = kianVspi_transfer_one;
+	master->setup = kianVspi_setup;
+	master->flags = 0;
+
+	/* get sck frequency */
+	ret = of_property_read_u32(node, "kianVfpga,sck-frequency", &val);
+	if (ret)
+		goto err;
+
+	master->min_speed_hz = val;
+	master->max_speed_hz = val;
+
+	/* get num cs */
+	ret = of_property_read_u32(node, "kianVfpga,num-cs", &val);
+	if (ret)
+		goto err;
+	master->num_chipselect = val;
+
+	hw = spi_controller_get_devdata(master);
+	hw->master = master;
+
+	/* get base address */
+	hw->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);
+	if (IS_ERR((void*)hw->regs)) {
+		ret = PTR_ERR((void*)hw->regs);
+		goto err;
+	}
+
+	/* register controller */
+	ret = spi_register_controller(spi_controller_get(master));
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	spi_controller_put(master);
+	return ret;
+}
+
+static const struct of_device_id kianVspi_match[] = {
+	{ .compatible = "kianVfpga,kianVspi-simple2" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, kianVspi_match);
+
+static struct platform_driver kianVspi_driver = {
+	.probe = kianVspi_probe,
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = of_match_ptr(kianVspi_match)
+	}
+};
+module_platform_driver(kianVspi_driver)
+
+MODULE_AUTHOR("Hirosh Dabui <hirosh@dabui.de");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/drivers/spi/spi-kianV-simple3.c b/drivers/spi/spi-kianV-simple3.c
new file mode 100644
index 000000000000..4c0fc6a476b6
--- /dev/null
+++ b/drivers/spi/spi-kianV-simple3.c
@@ -0,0 +1,180 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * kianV-Simple SPI controller driver
+ *
+ * Copyright (C) 2019 Antmicro Ltd. <www.antmicro.com>
+ * Copyright (C) 2021 Sylvain Munaut <tnt@246tNt.com>
+ * Copyright (C) 2023 Hirosh Dabui <hirosh@dabui.de>
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+#define DRIVER_NAME "kianVspi-simple3"
+
+struct kianVspi_regs {
+	uint32_t ctrl;
+	uint32_t data;
+} __attribute__((packed, aligned(4)));
+
+struct kianVspi_hw {
+	struct spi_controller *master;
+	volatile struct kianVspi_regs __iomem *regs;
+};
+
+static void kianVspi_set_cs(struct spi_device *spi, bool cs_n)
+{
+	struct kianVspi_hw *hw = spi_controller_get_devdata(spi->controller);
+
+	/* Set chip select */
+	hw->regs->ctrl = (cs_n ? 0 : BIT(spi->chip_select[0]));
+}
+
+static int kianVspi_transfer_one(struct spi_controller *ctrl,
+				 struct spi_device *spi, struct spi_transfer *t)
+{
+	struct kianVspi_hw *hw = spi_controller_get_devdata(ctrl);
+	const u8 *tx = t->tx_buf;
+	u8 *rx = t->rx_buf;
+	int i;
+
+	if (!hw || !t) {
+		return -EINVAL;
+	}
+
+	if (spi->kianv_spi_data_width == 8) {
+		for (i = 0; i < t->len; i++) {
+			while ((hw->regs->ctrl & 0x80000000) != 0) {
+				cpu_relax();
+			}
+
+			hw->regs->data = tx ? *tx++ : 0x00;
+
+			while ((hw->regs->ctrl & 0x80000000) != 0) {
+				cpu_relax();
+			}
+
+			if (rx) {
+				*rx++ = hw->regs->data;
+			}
+		}
+	} else /* 16 */ {
+		for (i = 0; i < t->len; i += 2) {
+			uint16_t data_to_send = 0;
+
+			data_to_send = *(uint16_t *)tx;
+			data_to_send = htons(data_to_send);
+
+			tx += 2;
+
+			uint8_t high_byte = (data_to_send >> 8) & 0xFF;
+			uint8_t low_byte = data_to_send & 0xFF;
+
+			while ((hw->regs->ctrl & 0x80000000) != 0) {
+				cpu_relax();
+			}
+			hw->regs->data = low_byte;
+
+			while ((hw->regs->ctrl & 0x80000000) != 0) {
+				cpu_relax();
+			}
+			if (rx) {
+				*rx++ = hw->regs->data;
+			}
+
+			hw->regs->data = high_byte;
+
+			while ((hw->regs->ctrl & 0x80000000) != 0) {
+				cpu_relax();
+			}
+			if (rx) {
+				*rx++ = hw->regs->data;
+			}
+		}
+	}
+	spi->kianv_spi_data_width = 8;
+	return 0;
+}
+
+static int kianVspi_setup(struct spi_device *spi)
+{
+	return 0;
+}
+
+static int kianVspi_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct kianVspi_hw *hw;
+	struct spi_controller *master;
+	//struct resource *res;
+	int ret;
+	u32 val;
+
+	master = spi_alloc_host(&pdev->dev, sizeof(*hw));
+	if (!master)
+		return -ENOMEM;
+
+	master->dev.of_node = pdev->dev.of_node;
+	master->bus_num = pdev->id;
+	master->mode_bits = SPI_MODE_0;
+	master->bits_per_word_mask = SPI_BPW_MASK(8);
+	master->set_cs = kianVspi_set_cs;
+	master->transfer_one = kianVspi_transfer_one;
+	master->setup = kianVspi_setup;
+	master->flags = 0;
+
+	/* get sck frequency */
+	ret = of_property_read_u32(node, "kianVfpga,sck-frequency", &val);
+	if (ret)
+		goto err;
+
+	master->min_speed_hz = val;
+	master->max_speed_hz = val;
+
+	/* get num cs */
+	ret = of_property_read_u32(node, "kianVfpga,num-cs", &val);
+	if (ret)
+		goto err;
+	master->num_chipselect = val;
+
+	hw = spi_controller_get_devdata(master);
+	hw->master = master;
+
+	/* get base address */
+	hw->regs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);
+	if (IS_ERR((void *)hw->regs)) {
+		ret = PTR_ERR((void *)hw->regs);
+		goto err;
+	}
+
+	/* register controller */
+	ret = spi_register_controller(spi_controller_get(master));
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	spi_controller_put(master);
+	return ret;
+}
+
+static const struct of_device_id kianVspi_match[] = {
+	{ .compatible = "kianVfpga,kianVspi-simple3" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, kianVspi_match);
+
+static struct platform_driver kianVspi_driver = {
+	.probe = kianVspi_probe,
+	.driver = { .name = DRIVER_NAME,
+		    .of_match_table = of_match_ptr(kianVspi_match) }
+};
+module_platform_driver(kianVspi_driver)
+
+MODULE_AUTHOR("Hirosh Dabui <hirosh@dabui.de");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/drivers/staging/fbtft/fb_ssd1331.c b/drivers/staging/fbtft/fb_ssd1331.c
index 06b7056d6c71..29927b4cc1c0 100644
--- a/drivers/staging/fbtft/fb_ssd1331.c
+++ b/drivers/staging/fbtft/fb_ssd1331.c
@@ -40,7 +40,7 @@ static int init_display(struct fbtft_par *par)
 	write_reg(par, 0xa4); /* NORMALDISPLAY */
 	write_reg(par, 0xa8, 0x3f); /* Set multiplex */
 	write_reg(par, 0xad, 0x8e); /* Set master */
-	/* write_reg(par, 0xb0, 0x0b);  Set power mode */
+	write_reg(par, 0xb0, 0x0b);  /* Set power mode */
 	write_reg(par, 0xb1, 0x31); /* Precharge */
 	write_reg(par, 0xb3, 0xf0); /* Clock div */
 	write_reg(par, 0x8a, 0x64); /* Precharge A */
@@ -63,11 +63,35 @@ static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
 	write_reg(par, 0x75, ys, ye);
 }
 
+#define KIANV_GPIO_HW_ADDR 0x10000700
 static void write_reg8_bus8(struct fbtft_par *par, int len, ...)
 {
 	va_list args;
 	int i, ret;
 	u8 *buf = par->buf;
+        u32 value;
+
+        static void __iomem *virt_addr;
+        static bool initialized = false;
+
+        if (!initialized) {
+            virt_addr = ioremap(KIANV_GPIO_HW_ADDR, PAGE_SIZE);
+            if (!virt_addr) {
+                printk(KERN_ERR "Failed to map physical address\n");
+                return;
+            }
+
+            // dir offset
+            value = readl(virt_addr + 0x00);
+            value |= (1 << 9);
+            writel(value, virt_addr + 0x00);
+
+            // output offset
+            value = readl(virt_addr + 0x04);
+            value |= (1 << 9); // set DC
+            writel(value, virt_addr + 0x04);
+            initialized = true;
+        }
 
 	if (unlikely(par->debug & DEBUG_WRITE_REGISTER)) {
 		va_start(args, len);
@@ -81,7 +105,11 @@ static void write_reg8_bus8(struct fbtft_par *par, int len, ...)
 	va_start(args, len);
 
 	*buf = (u8)va_arg(args, unsigned int);
-	gpiod_set_value(par->gpio.dc, 0);
+        // output
+        value = readl(virt_addr + 0x04);
+        value &= ~(1 << 9); // clear DC
+        writel(value, virt_addr + 0x04);
+	//gpiod_set_value(par->gpio.dc, 0);
 	ret = par->fbtftops.write(par, par->buf, sizeof(u8));
 	if (ret < 0) {
 		va_end(args);
@@ -103,7 +131,11 @@ static void write_reg8_bus8(struct fbtft_par *par, int len, ...)
 			return;
 		}
 	}
-	gpiod_set_value(par->gpio.dc, 1);
+	// output
+        value = readl(virt_addr + 0x04);
+        value |= (1 << 9); // set DC
+        writel(value, virt_addr + 0x04);
+	//gpiod_set_value(par->gpio.dc, 1);
 	va_end(args);
 }
 
diff --git a/drivers/staging/fbtft/fbtft-bus.c b/drivers/staging/fbtft/fbtft-bus.c
index 30e436ff19e4..d69483768b57 100644
--- a/drivers/staging/fbtft/fbtft-bus.c
+++ b/drivers/staging/fbtft/fbtft-bus.c
@@ -221,14 +221,15 @@ int fbtft_write_vmem8_bus8(struct fbtft_par *par, size_t offset, size_t len)
 }
 EXPORT_SYMBOL(fbtft_write_vmem8_bus8);
 
-/* 16 bit pixel over 16-bit databus */
 int fbtft_write_vmem16_bus16(struct fbtft_par *par, size_t offset, size_t len)
 {
-	u16 *vmem16;
+    u16 *vmem16;
 
 	vmem16 = (u16 *)(par->info->screen_buffer + offset);
 
-	/* no need for buffered write with 16-bit bus */
-	return fbtft_write_buf_dc(par, vmem16, len, 1);
+    // No need for buffered write with 16-bit bus
+    par->spi->kianv_spi_data_width = 16;
+    return fbtft_write_buf_dc(par, vmem16, len, 1);
 }
 EXPORT_SYMBOL(fbtft_write_vmem16_bus16);
+
diff --git a/drivers/staging/fbtft/fbtft-core.c b/drivers/staging/fbtft/fbtft-core.c
index 4cfa494243b9..e61e046f9b6f 100644
--- a/drivers/staging/fbtft/fbtft-core.c
+++ b/drivers/staging/fbtft/fbtft-core.c
@@ -34,11 +34,39 @@ static unsigned long debug;
 module_param(debug, ulong, 0000);
 MODULE_PARM_DESC(debug, "override device debug level");
 
+#define KIANV_GPIO_HW_ADDR 0x10000700
 int fbtft_write_buf_dc(struct fbtft_par *par, void *buf, size_t len, int dc)
 {
 	int ret;
 
-	gpiod_set_value(par->gpio.dc, dc);
+        static void __iomem *virt_addr;
+        static bool initialized = false;
+
+        if (!initialized) {
+            virt_addr = ioremap(KIANV_GPIO_HW_ADDR, PAGE_SIZE);
+            if (!virt_addr) {
+                printk(KERN_ERR "Failed to map physical address\n");
+                return -1;
+            }
+
+            // dir offset
+            int value = readl(virt_addr + 0x00);
+            value |= (1 << 9);
+            writel(value, virt_addr + 0x00);
+
+            // output offset
+            value = readl(virt_addr + 0x04);
+            value |= (1 << 9); // set DC
+            writel(value, virt_addr + 0x04);
+            initialized = true;
+        }
+
+        // output
+        int value = readl(virt_addr + 0x04);
+	value = (value & ~(1 << 9)) | ((dc & 1) << 9);
+
+        writel(value, virt_addr + 0x04);
+//	gpiod_set_value(par->gpio.dc, dc);
 
 	ret = par->fbtftops.write(par, buf, len);
 	if (ret < 0)
@@ -1054,7 +1082,7 @@ static int fbtft_verify_gpios(struct fbtft_par *par)
 	    !par->gpio.dc) {
 		dev_err(par->info->device,
 			"Missing info about 'dc' gpio. Aborting.\n");
-		return -EINVAL;
+	//	return -EINVAL;
 	}
 
 	if (!par->pdev)
@@ -1068,7 +1096,7 @@ static int fbtft_verify_gpios(struct fbtft_par *par)
 		if (!par->gpio.db[i]) {
 			dev_err(par->info->device,
 				"Missing 'db%02d' gpio. Aborting.\n", i);
-			return -EINVAL;
+			//return -EINVAL;
 		}
 	}
 
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 8497f4747e24..093e1527343a 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -188,6 +188,7 @@ struct spi_device {
 	u8			chip_select[SPI_CS_CNT_MAX];
 	u8			bits_per_word;
 	bool			rt;
+	u8			kianv_spi_data_width;
 #define SPI_NO_TX		BIT(31)		/* No transmit wire */
 #define SPI_NO_RX		BIT(30)		/* No receive wire */
 	/*
diff --git a/sound/Kconfig b/sound/Kconfig
index 8b40205394fe..c465376143ce 100644
--- a/sound/Kconfig
+++ b/sound/Kconfig
@@ -99,6 +99,8 @@ source "sound/xen/Kconfig"
 
 source "sound/virtio/Kconfig"
 
+source "sound/kianv/Kconfig"
+
 endif # SND
 
 endif # SOUND
diff --git a/sound/Makefile b/sound/Makefile
index 5942311a4232..35335e29db63 100644
--- a/sound/Makefile
+++ b/sound/Makefile
@@ -6,7 +6,8 @@ obj-$(CONFIG_SOUND) += soundcore.o
 obj-$(CONFIG_DMASOUND) += oss/dmasound/
 obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ \
 	firewire/ sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/ hda/ x86/ xen/ \
-	virtio/
+	virtio/ kianv/
+
 obj-$(CONFIG_SND_AOA) += aoa/
 
 # This one must be compilable even if sound is configured out
diff --git a/sound/kianv/Kconfig b/sound/kianv/Kconfig
new file mode 100644
index 000000000000..876f97b1f19c
--- /dev/null
+++ b/sound/kianv/Kconfig
@@ -0,0 +1,4 @@
+config SND_KIANV
+	tristate "KIANV SND"
+	help
+            KianV SND
diff --git a/sound/kianv/Makefile b/sound/kianv/Makefile
new file mode 100644
index 000000000000..49646a86d581
--- /dev/null
+++ b/sound/kianv/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_SND_KIANV) += kianv-snd.o
diff --git a/sound/kianv/kianv-snd.c b/sound/kianv/kianv-snd.c
new file mode 100644
index 000000000000..e332452fde41
--- /dev/null
+++ b/sound/kianv/kianv-snd.c
@@ -0,0 +1,111 @@
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/ktime.h>
+#include <linux/spinlock.h>
+#include <linux/uaccess.h>
+
+
+#define DEVICE_NAME "dsp"
+#define CLASS_NAME "audio"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hirosh Dabui");
+MODULE_DESCRIPTION("Driver for Sigma-Delta Converter");
+MODULE_VERSION("0.1");
+
+static int majorNumber;
+static struct class* audioClass = NULL;
+//static struct cdev audioCdev;
+static DEFINE_SPINLOCK(buffer_lock);
+
+
+static int dev_open(struct inode *, struct file *);
+static ssize_t dev_write(struct file *, const char *, size_t, loff_t *);
+static int dev_release(struct inode *, struct file *);
+
+static struct file_operations fops = {
+    .open = dev_open,
+    .write = dev_write,
+    .release = dev_release,
+};
+
+#define KIANV_SND_REG 0x10500000
+static void __iomem *virt_addr;
+static int __init audio_init(void) {
+    printk(KERN_INFO "Audio: Initializing the Audio LKM\n");
+
+    virt_addr = ioremap(KIANV_SND_REG, PAGE_SIZE);
+    if (!virt_addr) {
+        printk(KERN_ERR "Failed to map physical address\n");
+    }
+
+    majorNumber = register_chrdev(0, DEVICE_NAME, &fops);
+    if (majorNumber < 0) {
+        printk(KERN_ALERT "Audio failed to register a major number\n");
+        return majorNumber;
+    }
+    audioClass = class_create(CLASS_NAME);
+    if (IS_ERR(audioClass)) {
+        unregister_chrdev(majorNumber, DEVICE_NAME);
+        printk(KERN_ALERT "Failed to register device class\n");
+        return PTR_ERR(audioClass);
+    }
+    if (IS_ERR(device_create(audioClass, NULL, MKDEV(majorNumber, 0), NULL, DEVICE_NAME))) {
+        class_destroy(audioClass);
+        unregister_chrdev(majorNumber, DEVICE_NAME);
+        printk(KERN_ALERT "Failed to create the device\n");
+        return -1;
+    }
+    printk(KERN_INFO "Audio: device class created correctly\n");
+    return 0;
+}
+
+static void __exit audio_exit(void) {
+    device_destroy(audioClass, MKDEV(majorNumber, 0));
+    class_destroy(audioClass);
+    unregister_chrdev(majorNumber, DEVICE_NAME);
+    printk(KERN_INFO "Audio: Goodbye from the LKM!\n");
+}
+
+static int dev_open(struct inode *inodep, struct file *filep) {
+    printk(KERN_INFO "Audio: Device has been opened\n");
+    return 0;
+}
+
+static ssize_t dev_write(struct file *filep, const char __user *buffer, size_t len, loff_t *offset) {
+    unsigned long flags;
+    size_t i;
+    uint8_t data;
+    uint32_t status;
+
+    for (i = 0; i < len; ++i) {
+        if (copy_from_user(&data, buffer + i, 1) != 0) {
+            return -EFAULT;
+        }
+
+        do {
+            status = readl(virt_addr + 0x300);
+        } while (status & 0x1); // Continue looping while LSB is set
+
+
+        spin_lock_irqsave(&buffer_lock, flags);
+        writel(data, virt_addr + 0x300); // Perform the hardware write operation
+        spin_unlock_irqrestore(&buffer_lock, flags);
+    }
+
+    return i; // Return the number of bytes processed
+}
+
+
+
+static int dev_release(struct inode *inodep, struct file *filep) {
+    printk(KERN_INFO "Audio: Device successfully closed\n");
+    return 0;
+}
+
+
+module_init(audio_init);
+module_exit(audio_exit);
-- 
2.43.0

